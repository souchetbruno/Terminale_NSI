<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/default.css">
    <link rel="stylesheet" href="syntaxe_self.css">
    <link rel="shortcut icon" href="../img/site-icon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../css/code-highlighting/prism.css">
    <script src="../css/code-highlighting/prism.js"></script>

    <title>Python | Syntaxe</title>
</head>
<body>
    <div class="banner">
        <img src="../img/logo.PNG" id="logo">
        <p class="title">Python | Syntaxe</p>
        <img src="../img/qrcode_termNSI.svg" id="qrcode">
        <a href="../index.html" id="return-button"> « Retour</a>
    </div>
    <hr class="separator">
    <div class="content">
        <ol class="general-list">
            <div class="links">
                <div class="basics">
                    <a href="#commentaire" target="_self">1. Les commentaires</a><br>
                    <a href="#variable" target="_self">2. Les variables</a><br>
                    <a href="#cast" target="_self">3. Le Cast</a><br>
                    <a href="#str" target="_self">4. Les chaînes de caractères</a><br>
                    <a href="#boolean" target="_self">5. Les booléens</a><br>
                    <a href="#operateur" target="_self">6. Les opérateurs</a><br>
                    <a href="#lists" target="_self">7. Les listes/tableaux</a><br>
                    <a href="#tuples" target="_self">8. Les tuples</a><br>
                    <a href="#dicts" target="_self">9. Les dictionnaires</a><br>
                    <a href="#ifelifelse" target="_self">10. if...elif...else</a><br>
                    <a href="#whiles" target="_self">11. Les boucles while</a><br>
                    <a href="#fors" target="_self">12. Les boucles for</a><br>
                </div>
                <div class="complex">
                    <a href="#nested-loops" target="_self">13. Les boucles imbriquées</a><br>
                    <a href="#functions" target="_self">14. Les fonctions</a><br>
                    <a href="#classes" target="_self">15. Les classes</a><br>
                    <a href="#imports" target="_self">16. Les importations</a><br>
                    <a href="#files" target="_self">17. Les fichiers</a><br>
                </div>
            </div>
            <li id="commentaire">
                Le commentaire : se précède d'un # :  <code class="lang-py"> # Ceci est un commentaire </code>  mais peut aussi s'écrire d'une façon particulière <br> <code class="lang-py"> """ Ceci est un commentaire qui peut être multiligne, utilisé aussi dans les docstring """</code>
            </li>
            <li id="variable">
                La variable : <code class="lang-py">nom = valeur</code>, par exemple <code class="lang-py">a = 1</code> mais aussi <code class="lang-py">somme = 23.56</code> ou encore <code class="lang-py">nom = "Souchet"</code>
            </li>
            <li id="cast">
                Le cast : <code class="lang-py">variable = nom_du_type(variable_2)</code>, par exemple <code class="lang-py">a = int(15.9)</code> mais aussi <code class="lang-py">b = str(28)</code> ou encore <code class="lang-py">c = int("32")</code> <br>
                <em>A savoir : les types primaires existants sont : </em><code class="lang-py">str, int, float, complex, list, tuple, dict, set, frozenset, bool, bytes, bytearray, memoryview</code>
            </li>
            <li id="str">
                Les chaînes de caractère : Ils peuvent s'écrire de plusieurs façons, avec des guillemets simples : <code class="lang-py">'NSI'</code> ou avec des guillemets doubles <code class="lang-py">"NSI"</code>, vous pouvez aussi, comme pour les commentaires, tripler le symbole afin de faire une chaîne de caractère multiligne :
                <pre><code class="lang-py">
"""
Ceci
est
une chaîne de caractères
sur plusieurs lignes
"""
                </code></pre>
                Notez que les guillemets simples fonctionneront aussi
            </li>
            <li id="boolean">
                Les booléens : Sous leur forme stricte : <code class="lang-py">True</code> ou <code class="lang-py">False</code> ou alors sous forme de condition, qui (après calcul), ont le rôle de booléens : <br>
                <pre><code class="lang-py">
# la syntaxe d'une condition : 
valeur opération valeur

# par exemple :
5 == 5    # vaudra True

5 != 9    # vaudra True
5 == 9    # vaudra False

9 > 5     # vaudra True
9 &lt 5     # vaudra False

4 + 5 &gt 5 # vaudra True, car python lira ((4 + 5) > 5) soit (9 > 5) soit True

# on peut faire intervenir les opérateurs suivants : and, or, not et in

1 &lt 2 and 5 &lt 6 # vaudra True, mais
2 &lt 1 and 5 &lt 6 # vaudra False : 2 n'est pas inférieur a 1, et l'opérateur "and" nécessite True de chaque côté

1 &lt 2 or 5 &lt 6  # vaudra True, mais aussi
2 &lt 1 or 5 &lt 6  # vaudra True, car l'opérateur "or" nécessite qu'un (ou plus) True

# l'opérateur not permet d'inverser un booléen, et a ce titre une condition : 

not False      # vaut True
not True       # vaut False

# donc les exemples suivants fonctionnent : 

not (2 &lt 1)      # vaudra True  : car lu par python comme : not (False)   puis   True
not (5 + 3 &lt 9)  # vaudra False : car lu par python comme : not (8 &lt 9)   puis   not (False)   puis   True

# cas particulier du cast vers du booléen : 

bool(0)          # vaudra False, tout comme 
bool(None)       # c'est dû a une propriété du langage C, précurseur des langages de programmation actuels, cependant :

bool(25)
bool("NSI")
bool(456.86468)  # vaudront tous True, car différents de 0 et None, le type ici n'importe pas.
                </code></pre>
            </li>
            <li id="operateur">
                Les opérateurs : 
                <pre><code class="lang-py">
# Comme vu précédemment, les opérateurs jouent une part importante en programmation

a + b    # vaudra la somme de a et b
4 + 5    # vaudra 9

a - b    # vaudra la différence de a par b
a * b    # vaudra le produit de a par b
a / b    # vaudra le quotient de a par b (attention au type, int et float ne fonctionnent pas de la même façon !)

# des opérateurs moins connus 

a % b    # vaudra le reste d'une division euclidienne de a par b
a ** b   # vaudra le résultat de : a puissance b
a // b   # vaudra le quotient d'une division euclidienne de a par b (soit la partie entière de a / b)
                </code></pre>
                <br>
                Les opérateurs d'assignation : 
                <pre><code class="lang-py">
# Pour affecter une valeur, on peut écrire ceci (exemple) : 

a = a + 1   # pour augmenter a de 1, mais on peut aussi écrire
a += 1      # on place l'opérateur suivi d'un = pour expliquer la ré-affectation de la valeur. a devient alors a + 1

# Au même titre, les opérations d'assignation suivantes sont possibles :

a += b      # signifie : a = a + b
a -= b      # signifie : a = a - b
a *= b      # signifie : a = a * b
a /= b      # signifie : a = a / b
a %= b     # signifie : a = a % b
a //= b     # signifie : a = a // b
a **= b     # signifie : a = a ** b
                </code></pre>
            </li>
            <li id="lists">
                Les listes / tableaux, sont écrits avec des <b>crochets</b> : 
<pre><code class="lang-py">
# on écrit une liste / un tableau de la façon suivante

tab = [valeurs]

# par exemple : 

tab1 = [ ]
tab2 = [0]
tab3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # on sépare les différentes valeurs par des virgules
tab4 = ["J'apprends", "la", "syntaxe", "d'un", "tableau"]

</code></pre>
            </li>
            <li id="tuples">
                Les tuples / p-uplets, sont écrits avec des <b>parenthèses</b> :
<pre><code class="lang-py">
# on écrit un tuple / un p-uplet de la façon suivante

couple = (valeurs)

# par exemple : 

couple1 = ( )
couple2 = (0)
couple3 = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10) # on sépare les différentes valeurs par des virgules
couple4 = ("J'apprends", "la", "syntaxe", "d'un", "tuple")

</code></pre>
            </li>
            <li id="dicts">
                Les dictionnaires, sont écrits avec des <b>accolades</b> :
<pre><code class="lang-py">
# on écrit un dictionnaire de la façon suivante

dico = {cléA : valeurA, cléB : valeurB} # ou encore, et c'est mieux
dico2 = {
    cléA : valeurA,
    cléB : valeurB,
    cléC : valeurC
}

# Attention aux virgules entre les valeurs et clés lors des retours a la ligne.
# Des exemples : 

notes = {
    "Arnaud" : 18.5,
    "Mattéo" : 18,
    "Loan"   : 17,
    "Nathan" : 17,
    "Gabin"  : 12
}

notes2 = {
    "NSI" : "M.Souchet",
    "Physique-Chimie" : "M.Lompech",
    "Maths comp" : "M.Bernard",
    "Philo" : "M.Prunier",
    "Histoire-Géo" : "M.Freydefont",
    "Anglais" : "Mme.Servanty",
    "Allemand" : "Mme.Perthuis"
}

</code></pre>
            </li>
            <li id="ifelifelse">Les if ... elif ... else
                <pre><code class="lang-py">
# un bloc IF s'écrit ainsi : 

if condition : 
    # ici le bloc

# veillez a respecter les indentations liées aux blocs de code, par exemple :

if condition : 
#bloc de code

# provoquerait une erreur liée aux indentations non respectées (le if attend un bloc de code indenté)

# ensuite le elif, nécessite un if. Voici la syntaxe
if condition1 : 
    # bloc de code 1 si condition1
elif condition2 : 
    # bloc de code 2 si condition2 MAIS pas condition1

# et enfin le else
if condition1:
    # bloc de code si condition 1
else:
    # bloc de code si pas condition 1

# remarque, le else suit un if ou un elif, et le elif peut suivre un if ou un elif, exemple complet : 
if condition1:
    # bloc de code 1 si condition 1
elif condition2:
    # bloc de code 2 si condition 2 mais pas condition1
elif condition3:
    # bloc de code 3 si condition 3 mais pas condition1 ni condition2
else:
    # bloc de code 4 si aucune des condition précedentes a valu True
                </code></pre>
            </li>
            <li id="whiles">Les boucles while : 
                <pre><code class="lang-py">
# les boucles while s'écrivent ainsi :

while condition:
    # bloc de code qui s'éxecute tant que condition est vrai (soit condition vaut True)

# exemple : 
compteur = 1
while compteur &lt 6:
    compteur += 1
    print(compteur)
# affichera 1, 2, 3, 4, 5 et s'arrêtera car la condition vaudra False au 6e tour
                </code></pre>
            </li>
            <li id="fors">Les boucles for | La fonction range(): 
                <pre><code class="lang-py">
# les boucles fore s'écrivent ainsi :

for var in element:
    # bloc de code qui s'éxecute tant que var n'a pas parcouru toutes les valeurs de element

# exemple : 
tab = [1,2,3,4,5,6,7,8,9,10]
for nombre in tab:
    print(nombre)
# affichera chaque nombre de tab et s'arrêtera quand le bloc de code aura fini de s'executer pour la dernière valeur

# d'ailleurs : 
for lettre in "NSI":
    print(lettre)
# affichera N puis S puis I car les str sont des element dits itérables 
# (comme des listes, des tuple, qui contiennent des groupes de valeurs et qu'on peut parcourir)

# cas particulier, la fonction range(debut=0, fin+1, pas=1)
for nombre in range(6):
    print(nombre) # écrira : 0, 1, 2, 3, 4, 5 (5 car "fin + 1" est donné comme étant 6)

for nombre in range(1, 5):
    print(nombre) # écrira : 1, 2, 3, 4 (car le début est maintenant 1, et 4 car 4 + 1 vaut 5)

for nombre in range(0, 100, 2):
    print(nombre) # écrira 0, 2, 4, 6, ..., 100 (soit de 0 à 100 mais de 2 en 2, soit "pas à pas" )
                </code></pre>
            </li>
            <li id="nested-loops">Les boucles imbriquées, remarque générale : 
                <pre><code class="lang-py">
# les boucles imbriquées sont possibles en python, à condition de respecter l'indentation : 

# exemple
for nb in [1,2,3,4,5,6]:
    for nom in ["J'apprends","les","syntaxes"]:
        print(nb, nom)
                </code></pre>
            </li>
            <li id="functions">Les fonctions : 
                <pre><code class="lang-py">
# les fonctions en python se présentent ainsi : 
def nom_de_fonction(paramètres):
    # bloc de code indenté

# cependant, une fonction proprement écrite s'écrira ainsi : 
def nom_de_fonction(paramètre1:type_du_paramètre1, paramètre2:type_du_paramètre2, ...) -> type_de_retour:
    """la docstring, habitude a prendre"""
    # enfin, le bloc de code indenté

# un bon exemple ?
def bienvenue_en_nsi(nom:str, heure:int) -> str:
    """Renvoie un messagee de bienvenue en fonction du moment de la journée"""
    if heure &lt 12:
        return "Bon matin " + nom + " et bienvenue en NSI !"
    elif heure &gt 20:
        return "Bonsoir Nathan, tu t'es endormi à ce point ?"
    else:
        return "Bonjour " + nom + " et bienvenue en NSI !"

# les arguments par défaut, héritage du C/C++.
# un exemple : 
def payer(somme:int=0) -> bool:
    if somme &gt 1_000_000:
        print("Hein ? C'est quoi cette amende ??")
        return False
    elif somme == 135:
        print("Ah bon, mauvais stationnement")
        return True
    else:
        print("Je dois ", somme, "€ à qui déjà ?")
        return True
# dans le cas de la fonction payer : 
payer() # sera intérprété comme payer(0) car somme vaut par défaut 0.
                </code></pre>
            </li>
            <li id="classes">Les classes : 
                <pre><code class="lang-py">
# les classes, venant de la P.O.O s'écrivent d'une certaine façon, par exemple :
class TermGenNSI:

    def __init__(self, eleves:list, annee:int):
        self.eleves_absents = []
        self.eleves = eleves
        self.annee = annee
    
    def faire_l_appel(self) -> None:
        self.eleves_absents = []
        for eleve in self.eleves:
            if eleve.est_absent():
                self.eleves_absents.append(eleve)

# la fonction faire_l_appel est en fait une "méthode de classe" de la classe TermGenNSI.
# Le mot clé "self" placé en paramètres en fait une méthode, liée a son instance de classe.
# syntaxe globale : 

class NomDeLaClasse:

    def __init__(self, param_de_constructions):
        # bloc de code d'initialisation
    
    def nom_methode(self, param_methode) -> type_retour_methode:
        # bloc de code de méthode

# l'indentation entre le bloc de classe et de fichier est à respecter AUSSI.

# l'appel d'une méthode de classe nécessite une instance de classe. par exemple :

# on crée une instance de TermGenNSI, soit une "version"
classeNSI2022 = TermGenNSI(
    ["Raphael","Youri","Lenny","Arnaud","Mattéo","Axel","William","Charlélie","Noah","Nathan","Logan","Loan","Antonin","Nolan","Gabin"],
    2022
)
# et on utilise la méthode
classeNSI2022.faire_l_appel()
                </code></pre>
            </li>
            <li id="imports">Les imports, remarque générale : 
                <pre><code class="lang-py">
# les importations se font généralement en début de fichier, mais peuvent être placés dans des blocs conditionnels
# (pour économiser de la mémoire et du temps si elles ne servent pas toujours, les importations peuvent s'avérer coûteuses en RAM !)

# syntaxes générales

from module import fonction # ou plusieurs fonctions séparées par des virgules
import module

# exemple avec le module / package math

from math import sqrt, cos, sin
import math # chaque fonction utilisée nécessitera "math." en préfixe, tel que "math.sqrt()"

# l'utilisation de "as"
import Tkinter as tk
# importera le module Tkinter, et permettra son utilisation avec comme préfixe "tk" au lieu de "Tkinter"

from math import cos as cosinus
# importera la fonction cos du module math sous le nom cosinus
                </code></pre>
            </li>
            <li id="files">Les fichiers, syntaxe classique : 
                <pre><code class="lang-py">
# La syntaxe commune pour ouvrir un fichier avec python est la suivante :
with open("ficher.txt","mode") as variable_du_fichier:
    # bloc de code

# le chemin "fichier.txt" correspond a un chemin relatif, sauf si il débute par la racine du stockage du système. "\" pour Linux, "C:" pour Windows
# le mode d'intéraction change en fonction de l'utilisation du fichier, plus d'explications : https://www.w3schools.com/python/python_file_open.asp
# un exemple concret avec le tp des fleuves de première :

import csv
with open("NotesElèves1.csv", "r") as csvfile:
    d = csv.DictReader(csvfile, delimiter=';')
    table1 = []
    for ligne in d:
        table1.append(dict(ligne))

# ainsi le fichier NotesElèves1 est ouvert en mode lecture : "r" sous le nom "csvfile".
                </code></pre>
            </li>
        </ol>
    </div>
</body>
</html>